---
import Base from "../layouts/Base.astro";
import { Code } from "astro:components";
import CodeCard from "../components/CodeCard.astro";
import TextEditor from "../components/TextEditor.astro";
import Tabs from "../components/Tabs.astro";
import { codeToHtml } from "shiki";
import fs from "node:fs";
import path from "node:path";

const features = [
  {
    label: "Free",
    description:
      "No rate limits, no API keys. Switch to any provider, at any time.",
  },
  {
    label: "Easy Integration",
    description:
      "No package managers, no dependencies*. Just one copy and paste or download.",
  },
  {
    label: "Customizable",
    description: "Fine-tune your prompt, exactly how you like it.",
  },
  {
    label: "Choose Any Provider",
    description: "Paste your context directly into any chatbot UI.",
  },
  {
    label: "No Project Modifications",
    description: "No permanent files will be created, modified, or deleted.",
  },
  {
    label: "Open Source",
    description: "Add features. Open issues. All the code is on Github.",
  },
];

const promptTextfield = `The following are the diagnostics from the TypeScript compiler and ESLint. Tell me how to fix every error and/or warning. Tell me exactly what lines I need to modify in what file and what I need to change them to.`;

const posixShellUniversalPath = path.resolve(
  process.cwd(),
  "snippets/tested/posixShellUniversal.sh",
);
const posixShellUniversal: string = fs.readFileSync(
  posixShellUniversalPath,
  "utf8",
);

const posixShellUniversalInnerHTML = await getInnerHtml(
  posixShellUniversal,
  "sh",
);

const placeholderShell = String.raw`<Placeholder>The following are the diagnostics from the TypeScript compiler and ESLint. Tell me how to fix every error and/or warning. Tell me exactly what lines I need to modify in what file and what I need to change them to.<Placeholder>`;

const placeholderShellInnerHTML = await getInnerHtml(placeholderShell, "sh");

const learnCards = [
  {
    title: "Setup Shell Script",
    description: "Set up the shell environment and allow errors.",
    range: [1, 2],
  },
  {
    title: "Define Commands",
    description: "Find and define eslint, tsc, and node commands.",
    range: [4, 18],
  },
  {
    title: "Create Temporary Files",
    description: "Create temporary files, and fallback if mktemp is missing.",
    range: [20, 31],
  },
  {
    title: "Run ESLint",
    description: "Run ESLint and write JSON output to a temporary file.",
    range: [33, 34],
  },
  {
    title: "Run TypeScript Compiler",
    description: "Run Typescript Compiler write output to a temporary file.",
    range: [36, 37],
  },
  {
    title: "Use Node",
    description: "Use Node for JavaScript.",
    range: [39, 47],
  },
  {
    title: "Define constants",
    description:
      "Import filesystem, path, and temporary file paths. Create variables.",
    range: [48, 53],
  },
  {
    title: "Add File Paths",
    description: "Append normalized absolute file paths to a temporary file.",
    range: [55, 71],
  },
  {
    title: "Parse ESLint",
    description: "Parse ESLint JSON output from temporary file.",
    range: [73, 89],
  },
  {
    title: "Parse TypeScript Compiler",
    description: "Parse TypeScript Compiler output from temporary file.",
    range: [91, 115],
  },
  {
    title: "Write Header",
    description:
      "Write and format the prompt with diagnostics from both ESLint and TypeScript Compiler.",
    range: [117, 126],
  },
  {
    title: "Append Files",
    description:
      "Add the contents of the files mentioned in the diagnostics with line numbers.",
    range: [129, 136],
  },
  {
    title: "Delete Temporary Files",
    description:
      "Delete temporary files, keeping OUT_TXT if unable to copy to clipboard.",
    range: [138, 144],
  },
  {
    title: "Copy to Clipboard",
    description:
      "Attempt to copy to the system clipboard. Returns 1 if unsuccessful.",
    range: [146, 154],
  },
  {
    title: "Print summary",
    description: "Print success or failure and what action was done.",
    range: [156, 168],
  },
];

async function getInnerHtml(code: string, lang: string) {
  const html = await codeToHtml(code, { lang, theme: "github-dark" });

  return html
    .replace(/^.*?<code[^>]*>/s, "")
    .replace(/<\/code>\s*<\/pre>$/s, "");
}
---

<Base title="Clipboard Agent">
  <section id="hero" class="flex h-full justify-center">
    <div class="flex max-w-6xl flex-row items-center gap-8">
      <div class="flex basis-1/2 flex-col gap-8">
        <div class="flex flex-col gap-4">
          <h1 class="text-8xl font-bold">No APIs.<br />No installs.</h1>
          <p class="text-4xl text-slate-300">Just one file.</p>
        </div>
        <p class="text-xl text-slate-400">
          Looking for a different version?
          <a href="#customize" class="underline">Click here</a>
        </p>
      </div>
      <div class="flex basis-1/2">
        <CodeCard title="ca.sh (eslint + tsc)" monoTitle={true}>
          <Code
            class="astro-code max-h-[50vh] overflow-y-auto rounded-b p-4 break-words whitespace-pre-wrap"
            code={posixShellUniversal}
            lang="sh"
          />
        </CodeCard>
      </div>
    </div>

    <div
      class="absolute bottom-8 left-1/2 -translate-x-1/2 transition-opacity duration-300"
      data-chevron
    >
      <svg
        class="h-8 w-8 animate-bounce text-gray-500"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        viewBox="0 0 24 24"
      >
        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"
        ></path>
      </svg>
    </div>
  </section>

  <script is:inline>
    (function () {
      const hero = document.getElementById("hero");
      const cheveron = document.querySelector("[data-chevron]");
      if (!hero || !cheveron) return;

      const intersectionObserver = new IntersectionObserver(
        ([event]) => {
          const hide = event.intersectionRatio < 0.98;
          cheveron.classList.toggle("opacity-0", hide);
          cheveron.classList.toggle("pointer-events-none", hide);
        },
        { threshold: [0, 0.98] },
      );

      intersectionObserver.observe(hero);
    })();
  </script>

  <section id="features" class="flex justify-center p-16">
    <div class="flex max-w-6xl flex-col gap-8">
      <h2 class="text-center text-4xl font-semibold">Features</h2>
      <ul class="grid grid-cols-1 gap-8 md:grid-cols-2 lg:grid-cols-3">
        {
          features.map(({ label, description }) => (
            <li class="flex flex-col gap-2 rounded border border-gray-700 bg-gray-800 p-6">
              <h3 class="flex text-2xl">{label}</h3>
              <p class="text-gray-300">{description}</p>
            </li>
          ))
        }
      </ul>
      <p class="text-sm text-gray-500">
        *Node.js, ESLint, and TypeScript are required, but we assume you already
        have them if you're using this.
      </p>
    </div>
  </section>

  <section id="learn" class="flex justify-center p-16">
    <div class="flex max-w-6xl flex-col gap-8">
      <h2 class="text-center text-4xl font-semibold">How It Works</h2>
      <div class="grid grid-cols-1 gap-8 lg:grid-cols-2">
        <div id="learn-steps" class="flex flex-col gap-128 py-128">
          {
            learnCards.map((card) => (
              <article
                class="flex animate-[fade-center_1s_linear_both] flex-col gap-8 rounded border border-gray-700 bg-gray-800 p-6 [animation-range:cover] [animation-timeline:view()]"
                data-range={`${card.range[0]}-${card.range[1]}`}
              >
                <div class="flex flex-col gap-2">
                  <h3 class="text-2xl font-semibold">{card.title}</h3>
                  <h4 class="text-gray-300">{card.description}</h4>
                </div>
                <p class="text-sm text-gray-500">
                  Lines {card.range[0]}â€“{card.range[1]}
                </p>
              </article>
            ))
          }
        </div>
        <div class="self-start lg:sticky lg:top-8">
          <CodeCard title="ca.sh" monoTitle={true}>
            <div
              class="code-scroller max-h-[75vh] overflow-hidden"
              id="scroller"
            >
              <Code
                id="learn-code"
                class="astro-code block p-4 break-words whitespace-pre-wrap"
                code={posixShellUniversal}
                lang="sh"
              />
            </div>
          </CodeCard>
        </div>
      </div>
    </div>

    <style is:global>
      #learn-code .line {
        display: block;
      }
      #learn-code .line:empty::before {
        content: "\00a0";
      }

      #learn-code .active-line {
        background: rgba(255, 255, 255, 0.08);
      }

      #learn .code-scroller {
        scroll-padding-top: 1rem;
      }

      #learn #learn-code.astro-code {
        padding-left: 0;
        padding-right: 0;
      }

      /* Re-add the padding to the text itself */
      #learn #learn-code code {
        display: block;
        padding: 0 1rem;
      }

      /* Each line is a full-width block */
      #learn #learn-code .line {
        display: block;
      }

      /* Highlight fills the whole row, including the left/right padding */
      #learn #learn-code .active-line {
        background: rgba(255, 255, 255, 0.08);
        margin-left: -1rem;
        margin-right: -1rem;
        padding-left: 1rem;
        padding-right: 1rem;
      }

      @keyframes fade-center {
        0% {
          opacity: 0;
        }
        30% {
          opacity: 1;
        }
        70% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
    </style>

    <script is:inline>
      (function () {
        // Strictly scope to the learn code block.
        const scroller = document.querySelector("#learn .code-scroller");

        // add this helper near the top of the IIFE, after `const scroller = ...`
        function scrollGroupIntoView(
          scrollerEl,
          firstEl,
          lastEl,
          marginPx = 24,
        ) {
          if (!scrollerEl || !firstEl) return;
          const sRect = scrollerEl.getBoundingClientRect();
          const fRect = firstEl.getBoundingClientRect();
          const lRect = (lastEl || firstEl).getBoundingClientRect();

          // bounds of highlighted block in scroller coordinates
          const groupTop =
            fRect.top - sRect.top + scrollerEl.scrollTop - marginPx;
          const groupBottom =
            lRect.bottom - sRect.top + scrollerEl.scrollTop + marginPx;

          const viewTop = scrollerEl.scrollTop;
          const viewBottom = viewTop + scrollerEl.clientHeight;

          let nextTop = viewTop;
          if (groupTop < viewTop) nextTop = groupTop;
          else if (groupBottom > viewBottom)
            nextTop = groupBottom - scrollerEl.clientHeight;

          if (Math.abs(nextTop - viewTop) > 1) {
            // instant to avoid jitter while scrolling the left column
            scrollerEl.scrollTo({ top: nextTop });
          }
        }

        const codeRoot =
          scroller?.querySelector("pre.astro-code") ||
          document.querySelector("#learn pre.astro-code");

        function stripInterlineNewlines(root) {
          const code =
            root.tagName === "PRE" ? root.querySelector("code") : root;
          if (!code) return;
          for (const n of Array.from(code.childNodes)) {
            if (n.nodeType === Node.TEXT_NODE && /^\n+$/.test(n.nodeValue))
              n.nodeValue = "";
          }
        }

        stripInterlineNewlines(codeRoot);

        const stepEls = Array.from(
          document.querySelectorAll("#learn-steps [data-range]"),
        );

        if (!scroller || !codeRoot || !stepEls.length) return;

        // --- line + token helpers (unchanged behavior) ---
        function ensureLineSpans(root) {
          const pre = root.tagName === "PRE" ? root : root.querySelector("pre");
          const code = pre ? pre.querySelector("code") : null;
          let lineNodes = code
            ? code.querySelectorAll("span.line")
            : root.querySelectorAll(".line");
          if (lineNodes && lineNodes.length) return Array.from(lineNodes);

          const target = code || pre || root;
          if (!target) return [];
          target.innerHTML = target.textContent
            .split("\n")
            .map(
              (l) =>
                `<span class="line">${l.replace(/&/g, "&amp;").replace(/</g, "&lt;")}</span>`,
            )
            .join("");
          return Array.from(target.querySelectorAll(".line"));
        }

        const lineSpans = ensureLineSpans(codeRoot);

        function clearHighlights() {
          lineSpans.forEach((n) => n.classList.remove("active-line"));
          codeRoot.querySelectorAll("mark[data-sublight]").forEach((m) => {
            const parent = m.parentNode;
            while (m.firstChild) parent.insertBefore(m.firstChild, m);
            parent.removeChild(m);
          });
        }

        function wrapTokens(node, tokens) {
          const walker = document.createTreeWalker(
            node,
            NodeFilter.SHOW_TEXT,
            null,
          );
          const pieces = [];
          while (walker.nextNode()) pieces.push(walker.currentNode);
          pieces.forEach((textNode) => {
            tokens.forEach((tok) => {
              const idx = textNode.nodeValue.indexOf(tok);
              if (idx >= 0) {
                const before = document.createTextNode(
                  textNode.nodeValue.slice(0, idx),
                );
                const mark = document.createElement("mark");
                mark.setAttribute("data-sublight", "");
                mark.textContent = tok;
                const after = document.createTextNode(
                  textNode.nodeValue.slice(idx + tok.length),
                );
                const parent = textNode.parentNode;
                parent.insertBefore(before, textNode);
                parent.insertBefore(mark, textNode);
                parent.insertBefore(after, textNode);
                parent.removeChild(textNode);
              }
            });
          });
        }

        function highlightRange(start, end, tokens) {
          if (!lineSpans.length) return;
          const a = Math.max(1, start) - 1;
          const b = Math.min(lineSpans.length, end) - 1;
          for (let i = a; i <= b; i++)
            lineSpans[i]?.classList.add("active-line");

          if (tokens && tokens.length) {
            for (let i = a; i <= b; i++) wrapTokens(lineSpans[i], tokens);
          }

          const first = lineSpans[a];
          const last = lineSpans[b];
          scrollGroupIntoView(scroller, first, last, 24);
        }

        let currentEl = null;
        function setActiveStep(el) {
          if (!el || el === currentEl) return;
          currentEl = el;

          stepEls.forEach((s) => s.classList.toggle("step-active", s === el));
          clearHighlights();

          const [start, end] = el
            .getAttribute("data-range")
            .split("-")
            .map(Number);
          let tokens = null;
          const tokensAttr = el.getAttribute("data-tokens");
          try {
            tokens = tokensAttr ? JSON.parse(tokensAttr) : null;
          } catch {
            tokens = null;
          }
          highlightRange(start, end, tokens);
        }

        // --- center-band IntersectionObserver selection ---
        const visible = new Map(); // Element -> intersectionRatio

        const io = new IntersectionObserver(
          (entries) => {
            for (const e of entries) {
              if (e.isIntersecting) visible.set(e.target, e.intersectionRatio);
              else visible.delete(e.target);
            }
            // Prefer the most visible step inside the band, else closest to center.
            let candidate = null;
            let bestRatio = -1;
            for (const [el, ratio] of visible.entries()) {
              if (ratio > bestRatio) {
                bestRatio = ratio;
                candidate = el;
              }
            }
            if (!candidate) {
              // fallback by center distance
              const center = window.innerHeight * 0.5;
              let bestDist = Infinity;
              for (const el of stepEls) {
                const r = el.getBoundingClientRect();
                const mid = r.top + r.height / 2;
                const d = Math.abs(mid - center);
                if (d < bestDist) {
                  bestDist = d;
                  candidate = el;
                }
              }
            }
            setActiveStep(candidate);
          },
          {
            // Activation band around the center to avoid flicker.
            root: null,
            rootMargin: "-45% 0px -45% 0px",
            threshold: [0, 0.1, 0.25, 0.5, 0.75, 1],
          },
        );

        stepEls.forEach((el) => io.observe(el));

        // Handle resizes and content changes.
        const ro = new ResizeObserver(() => {
          // Force IO callback via synthetic scroll tick.
          requestAnimationFrame(() => setActiveStep(currentEl || stepEls[0]));
        });
        stepEls.forEach((el) => ro.observe(el));

        // First paint.
        setActiveStep(stepEls[0] || null);
      })();
    </script>
  </section>

  <section id="customize" class="flex justify-center p-16">
    <div class="flex max-w-6xl flex-col gap-8">
      <h2 class="text-center text-4xl font-semibold">Customize</h2>
      <div class="flex flex-row gap-8">
        <div class="flex basis-1/2 flex-col gap-4">
          <Tabs
            options={[
              { value: "compact", label: "One-liner" },
              { value: "readable", label: "Shell script" },
            ]}
            name="codeVersion"
            defaultValue="compact"
            targetId="exp-code"
          />
          <TextEditor
            targetId="exp-code"
            label="Prompt"
            initial={promptTextfield}
            placeholder="Your custom prompt here..."
          />
        </div>
        <div class="flex basis-1/2">
          <CodeCard title="ca.sh" monoTitle={true}>
            <pre
              id="exp-code"
              class="astro-code language-sh h-[50vh] overflow-y-auto rounded-b bg-[#24292e] p-4 break-words whitespace-pre-wrap"
              data-inner-readable={placeholderShellInnerHTML}><code set:html={posixShellUniversalInnerHTML} /></pre>

            <script is:inline>
              (function () {
                // Store both versions
                const NEEDLE =
                  "The following are the diagnostics from the TypeScript compiler and ESLint. Tell me how to fix every error and/or warning. Tell me exactly what lines I need to modify in what file and what I need to change them to.";

                // You'll need to pass these from Astro scope - add these as data attributes on exp-code
                let currentVersion = "compact";
                let innerCompact = null;
                let innerReadable = null;

                function escapeForJsSingleQuotedVisible(s) {
                  return s
                    .replace(/\\/g, "\\\\")
                    .replace(/'/g, "\\'")
                    .replace(/"/g, '\\"')
                    .replace(/`/g, "\\`")
                    .replace(/\$\{/g, "\\${")
                    .replace(/\r\n|\r|\n/g, "\\n")
                    .replace(/\t/g, "\\t");
                }

                const pre = document.getElementById("exp-code");
                if (!pre) return;
                const code = pre.querySelector("code");
                if (!code) return;

                // Store original HTML versions
                innerCompact = code.innerHTML;
                // You need to store innerReadable - add as data attribute
                innerReadable = pre.dataset.innerReadable || innerCompact;

                function switchVersion(version) {
                  currentVersion = version;
                  code.innerHTML =
                    version === "compact" ? innerCompact : innerReadable;
                  setupPromptEditing();
                }

                function setupPromptEditing() {
                  // Find and wrap the needle
                  const w = document.createTreeWalker(
                    code,
                    NodeFilter.SHOW_TEXT,
                  );
                  let span;
                  while (w.nextNode()) {
                    const n = w.currentNode;
                    const i = n.nodeValue.indexOf(NEEDLE);
                    if (i < 0) continue;

                    const before = n.nodeValue.slice(0, i);
                    const after = n.nodeValue.slice(i + NEEDLE.length);

                    span = document.createElement("span");
                    span.dataset.edit = "prompt";
                    span.textContent = escapeForJsSingleQuotedVisible(NEEDLE);

                    const frag = document.createDocumentFragment();
                    if (before)
                      frag.appendChild(document.createTextNode(before));
                    frag.appendChild(span);
                    if (after) frag.appendChild(document.createTextNode(after));
                    n.parentNode.replaceChild(frag, n);
                    break;
                  }
                  if (!span) return;

                  // Wire the textarea -> escaped content
                  const field = document.querySelector("textarea[data-target]");
                  if (!field) return;

                  const apply = (v) => {
                    span.textContent = escapeForJsSingleQuotedVisible(v);
                  };
                  apply(field.value || "");

                  // Remove old listeners to prevent duplicates
                  const newField = field.cloneNode(true);
                  field.parentNode.replaceChild(newField, field);
                  newField.addEventListener("input", () =>
                    apply(newField.value),
                  );
                }

                // Initial setup
                setupPromptEditing();

                // Listen for tab changes
                window.addEventListener("exp-code-change", (e) => {
                  switchVersion(e.detail.value);
                });
              })();
            </script>
          </CodeCard>
        </div>
      </div>
    </div>
  </section>

  <section id="contribute" class="flex min-h-dvh justify-center p-16">
    <div
      class="flex h-full w-full max-w-6xl flex-col justify-center gap-32 text-center"
    >
      <div class="flex flex-col gap-8">
        <h2 class="text-4xl font-semibold">Contribute</h2>
        <div class="flex flex-col gap-4">
          <span class="text-xl text-gray-200">
            Feel free to contribute to this project. It is open source on <a
              href="https://github.com/GithubUser3280/clipboard-agent"
              class="underline">GitHub</a
            >.
          </span>
          <span class="text-xl text-gray-200">
            Don't expect the code the be clean; its just a weekend project to
            test out static websites on Cloudflare.
          </span>
          <span class="text-gray-400"
            >Found a bug? Report it <a
              href="https://github.com/GithubUser3280/clipboard-agent/issues/new"
              class="underline">here</a
            >.</span
          >
        </div>
      </div>
      <p>2025 Ryan Hsieh</p>
    </div>
  </section>
</Base>
